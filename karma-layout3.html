<html>
<head>
<link rel="stylesheet" href="style.css">
<script type="text/javascript" src="jquery.js">
</script>
<script type="text/javascript" src="d3.v3.min.js">
</script>
</head>


<body>
<script type="text/javascript">
//width and height of scope
var padding = 35;
var width=window.innerWidth - padding;           
var height=window.innerHeight - padding;
var columns = 35;
var barWidth = 100;
var barHeight = 100;

//return color of node
var cScale = d3.scale.category20();            

//create svg
svg = d3.select("body")                         
    .append("svg")
    .attr("width", Math.max(width, columns * barWidth))
    .attr("height", height)
    .on("mousemove", mousemove);

//svg to draw nodes and links
var forceSVG = svg.append("g");

//place to show mouse coordinate
pos = svg.append("text")
	.attr("fill", "black")
	.attr("font-size", 10);

//x-scale
var xScale = d3.scale.linear()
	.domain([0, columns])                        
	.range([0, barWidth * columns]);

//coefficient of force move nodes to top
var upperForceScale = d3.scale.linear()
	.domain([0, height]) 
	.range([1, 0]);        


var test = [];
var anchorData = [];                           //store anchor nodes
var nodesData = [];                            //store all nodes includes anchors
var linksData = [];                            //links data
var textData = [];                             //text nodes
var textLinksData = [];                        //text links
var idMap = [];                                //map from label to id
var layerMap = [];                             //store nodes'id in sequence of layers
var nodesChildren = [];                        //store node's id and its children pair
//var xPosMap = [];                              //how many nodes in x position


var nodeRadius = 8;
var unitLinkLength = 70;                       //difference between layers
var maxLayer = 0;
var reshuffleFrequency = 10;                   //pixel changes to excute scroll bar event
var xOffset = 0;                               //x position offset
var outsideNodesNum = 0;                       //outside nodes number
var firstTime = true;     


var nodes = forceSVG.selectAll(".node");       //all nodes    
var links = forceSVG.selectAll(".link");       //all links
var labels = forceSVG.selectAll(".label");     //all labels
var labelLinks = forceSVG.selectAll("labelLinks"); //all label links.
var linkArrow = forceSVG.selectAll("linkArrow");   //little triangle of links


//force layout for nodes
var force = d3.layout.force()
	.size([Math.max(width, columns * barWidth), height])
	.gravity(0)
	.linkStrength(function(d){
		if (d.source.outside.isOutside || d.target.outside.isOutside){
			return 0.7;
		}
		return 0;
	})
	.friction(0.8)
	//.theta(0.1)
	.charge(-100)
	.linkDistance(30)
	.on("tick", tick);

// force layout for labels
var labelForce = d3.layout.force()
	.size([Math.max(width, columns * barWidth), height])
	.gravity(0)
	.friction(0.8)
	.charge(function(d){
		if (d.isOutside){
			return 0;
		}
		return -30;
	})
	.linkDistance(0)
	//.linkStrength(1);

//node can be dragged to the position you want
var drag = force.drag()
	.on("dragstart", function(d) {
		if (!d.outside.isOutside){
  			d3.select(this).classed("fixed", d.fixed = true);
		}
  	})
    .on("dragend", function(d) {
  		if (!d.outside.isOutside){
  			d.position.x = d.x;
  			d.position.y = d.y;
  		}
	});

//read file and execute program
//d3.json("datasets/complex/complex02.json", function(d){
d3.json("datasets/simple/simple06.json", function(d){
	var tmpNodeData = d.anchors.concat(d.nodes);
	var tmpLinkData = d.links;
	initializeData(tmpLinkData, tmpNodeData);
	setLayer();
	drawTable();

	transit();

	force.nodes(nodesData)
		.links(linksData)
		.start();

	labelForce.nodes(textData)
		.links(textLinksData)
		.start();

	setNodePosition();
});



//draw nodes and links
function transit(){
	links = links.data(linksData)
	links.enter()
		.append("path")
		.classed("link", true)
		.attr("stroke", "#555")
		.attr("stroke-width", 0)
		//.attr("opacity", 0.5)
		.attr("id", function(d, i){
			return d.source.id + "link" + d.target.id;
		})
		.attr("fill", "none");
	links.transition()
		.delay(250)
		.duration(500)
		.attr("stroke-width", 1);


	linkArrow = linkArrow.data(linksData);
	linkArrow.enter()
		.append("polygon")
		.attr("fill", "#555")
		//.attr("opacity", 0.6);


	labels = labels.data(textData)
		.enter()
		.append("g")
		.classed("label", true);
	labels.append("circle")
		.attr("r", 0)
		//.attr("fill", "white");
	labels.append("text")
		.text(function(d, i){
			return i % 2 == 0 ? "" : d.content;
		})
		.classed("labelText", true)
		.classed("hiddenText", function(d){			
			return true;
		})
		.attr("id", function(d, i){
			if (d.type == "nodeLabel"){
				d3.select(this)
					.classed("nodeLabel", true);
				return "nodeLabel" + d.node.id;
			} else if (d.type == "linkLabel"){
				d3.select(this)
					.classed("linkLabel", true);
				return "linkLabel" + nodesData[d.node.src].id + " " + nodesData[d.node.tgt].id;
			}
			return "labelPart" + i;
		});
		
	labelLinks = labelLinks.data(textLinksData);
	labelLinks.enter()
		.append("line")
		.classed("labelLinks", true)
		.attr("stroke-width", 0);
	//labels.moveToBack();


	nodes = nodes.data(nodesData);
	nodes.enter()
		.append("circle")
		.classed("node", true)
		.attr("r", 1)
		.attr("fill", function(d, i){
			d.position = {};
			d.position.x = barWidth * (0.5 + d.xposCol);
			d.position.y = height - barHeight - nodeRadius - d.layer * unitLinkLength;
			d.outside = {};
			d.outside.position = {};
			d.outside.isOutside = false;
			return cScale(i + 1);
		})
		.attr("id", function(d, i){
			return "node" + d.id;
		})
		.call(drag)
		.on("click", function(d){
			if (d.outside.isOutside){
				if (d.position.x < xOffset){		
					var destination = Math.max(0, d.position.x - width / 2);
					var xPosition = window.pageXOffset;
					var differ = Math.max(30, (xPosition - destination) / 200);
					var interval = setInterval(function(){
						xPosition -= differ;
						if (xPosition > destination){
							$(window).scrollLeft(xPosition);
						} else {
							clearInterval(interval);
						}
					}, 10);
				} else {
					var destination = Math.min(Math.max(width, columns * barWidth) - width, d.position.x - width / 2);
					var xPosition = window.pageXOffset;
					var differ = Math.max(30, (destination - xPosition) / 200);
					var interval = setInterval(function(){
						xPosition += differ;
						if (xPosition < destination){
							$(window).scrollLeft(xPosition);
						} else {
							clearInterval(interval);
						}
					}, 10);
				}				
			}
		})
		.on("dblclick", function(d) {
  			d3.select(this).classed("fixed", d.fixed = false);
  			d.position.x = barWidth * (0.5 + d.xposCol);
			d.position.y = height - barHeight - nodeRadius - d.layer * unitLinkLength;
		})
		.on("mouseover", function(d){
			d3.select("#nodeLabel" + d.id)
				.classed("hiddenText", false);
			d.showLabel = true;
			if (d.parent){
				d3.select("#nodeLabel" + d.parent)
					.classed("hiddenText", false);
				nodesData[d.parent].showLabel = true;
			}
			nodesChildren[d.id].forEach(function(e){
				if (nodesData[e].degree >= 2){
					d3.select("#nodeLabel" + e)
						.classed("hiddenText", false);
					nodesData[e].showLabel = true;
				}
			});
		})
		.on("mouseout", function(d){
			if (d.outside.isOutside){
				if (d.degree < 3){
					d3.select("#nodeLabel" + d.id)
						.classed("hiddenText", true);
					d.showLabel = false;
				}
				if (d.parent && nodesData[d.parent].degree < 3){
					d3.select("#nodeLabel" + d.parent)
						.classed("hiddenText", false);
					d.showLabel = true;
				}
				nodesChildren[d.id].forEach(function(e){
					if (nodesData[e].degree < 3){
						d3.select("#nodeLabel" + e)
							.classed("hiddenText", true);
						nodesData[e].showLabel = false;
					}
				});
			} else if (d.type == "anchor"){
				d3.select("#nodeLabel" + d.id)
					.classed("hiddenText", true);
				d.showLabel = false;
			}
		});
	nodes.transition()
		.duration(500)
		.attr("r", nodeRadius);
}

function tick(e){
	labelForce.start();
	var k = 0.03 * e.alpha;
	
	links.call(updateLink);
   

   	var kY = 0.05;
   	//kY = k * 5;
   	if (firstTime){
   		firstTime = false;
   		kY *= 10;
   	}
	nodes.attr("cx", function(d) {
			if (d.outside.isOutside){				
				return d.x = Math.max(xOffset + nodeRadius, Math.min(xOffset + width - nodeRadius, d.x));
			} 
			var differX = d.position.x - d.x;
			if (d.type == "anchor"){
				d.x += differX * kY;
				if (Math.abs(d.position.x - d.x) < 20){
        			d.x = d.position.x;
        		}
			} else {
    			d.x += differX * kY;
			}
    		return d.x;
    	})
        .attr("cy", function(d) { 
        	if (d.outside.isOutside){
        		d.y += -d.y * k;
        		return d.y = Math.max(nodeRadius, Math.min(height - nodeRadius, d.y));
        	}
        	var differY = d.position.y - d.y;
        	if (d.type == "anchor"){
        		d.y += differY * kY;
        		if (Math.abs(d.position.y - d.y) < 20 || d.y >= height - barHeight - nodeRadius){
        			d.y = d.position.y;
        		}
        	} else {
        		d.y += differY * kY;
        	}
        	return d.y;
        });
    


    labels.each(function(d, i){
    	if (i % 2 == 0){
    		if (d.type){
    			var a = nodesData[d.node.src];
    			var b = nodesData[d.node.tgt];
    			d.x = (a.x + b.x) / 2;
    			d.y = (a.y + b.y) / 2;
    		} else {
    			d.x = d.node.x;
    			d.y = d.node.y;
    		} 
    	} else {
    		var b = this.childNodes[1].getBBox();
			var diffX = d.x - textData[i - 1].x;
			var diffY = d.y - textData[i - 1].y;
			var dist = Math.sqrt(diffX * diffX + diffY * diffY);
			var shiftX = b.width * (diffX - dist) / (dist * 2) / 2;
			shiftX = Math.max(-b.width, Math.min(0, shiftX));
			var shiftY = 2;
			this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
    	}
    })

    labels.call(updateLabel);
    labelLinks.call(updateLabelLink);  	
}

//updata link for tick function
var updateLink = function(){
    this.attr("d", function(d){
			var a = d.source;
			var b = d.target;
			if ((a.outside.isOutside && b.outside.isOutside) || (b.outside.isOutside && b.type == "anchor")){
				return "M" + b.x + " " + b.y + " L " + a.x + " " + a.y;
			}
			var ay = a.y + (b.y - a.y) / 5;
			var ax = a.x + (b.x - a.x) / 3;
			var by = b.y - (b.y - a.y) / 3;
			//var p = "M " + b.x + " " + b.y + " C " + b.x + " " + by + " " + a.x + " " + ay + " " + a.x + " " + a.y;
			var p = "M " + b.x + " " + b.y + " C " + b.x + " " + by + " " + ax + " " + a.y + " " + a.x + " " + a.y;
			//var p = "M " + b.x + " " + b.y + " Q " + b.x + " " + by + " " + a.x + " " + a.y;
			return p;
	});	

	linkArrow.attr("points", function(d){
		if (d.target.outside.isOutside){
			return "";
		}
		d.slope = (d.target.x - d.source.x) / (d.target.y - d.source.y);
		d.angle = -Math.atan(d.slope / 6) / Math.PI * 180;

		var ax = d.target.x;
		var ay = d.target.y - nodeRadius;
		var bx = ax - 6;
		var by = ay - 6 * 1.7;
		var cx = ax + 6;
		var cy = by;

		return ax + "," + ay + " " + bx + "," + by + " " + cx + "," + cy;
	})
	.attr("transform", function(d){
		if (!d.target.outside.isOutside){
			return "rotate(" + d.angle + " " + d.target.x + " " + d.target.y + ")";
		}
	})
	/*.attr("transform", function(d){
		if (!d.target.outside.isOutside){
			return "translate(" + d.angle + " " + d.target.x + " " + d.target.y + ")";
		}
	});*/
}

//updata links of labels for tick function
var updateLabelLink = function(){
	this.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
}

//update label of nodes for tick function
var updateLabel = function() {
	this.attr("transform", function(d) {
		//dx = Math.max(xOffset + 20, Math.min(xOffset + width, d.x)); 
		//d.y = Math.max(nodeRadius, Math.min(height - nodeRadius, d.y)); 
		return "translate(" + d.x + "," + d.y + ")";
	});
}

//initialize data
function initializeData(tmpL, tmpN){
	tmpN.forEach(function(d, i){
		var node = {};
		node.label = d.id;
		node.id = i;
		node.degree = 0;
		node.showLabel = false;
		if (d.column || d.column == 0){
			node.column = d.column;
			node.type = "anchor";
			node.layer = 0;
			node.xposCol = d.column;
			anchorData.push(node);
			layerMap[i] = 1;
		} else {
			node.type = "node";
		}
		nodesData.push(node);
		idMap[d.id] = i;

	
		textData.push({node : node});
		textData.push({
			node : node,
			content : d.label,
			type : "nodeLabel"
		});

		textLinksData.push({
			source : textData.length - 2,
			target : textData.length - 1
		});
		
	});

	tmpL.forEach(function(d, i){
		var edge = {};
		edge.source = idMap[d.source];
		edge.target = idMap[d.target];
		edge.id = i;
		linksData.push(edge);

		var node = {};
		node.src = edge.source;
		node.tgt = edge.target;
		textData.push({
			node : node,
			type : "linkCircle"
		});
		textData.push({
			node : node,
			type : "linkLabel",
			content : d.label
		});

		textLinksData.push({
			source : textData.length - 2,
			target : textData.length - 1
		});
	});
}

//set layer and position for each node
function setLayer(){
	//layer is set from bottem to top, one layer per loop. The anchors are layer 0.
	var change = anchorData.length;
	var tmpLinkData = linksData.slice(0);
	while (change > 0){
		var tmpLayerMap = [];
		change = 0;
		tmpLinkData.forEach(function(d){
			var src = d.source;
			var tgt = d.target;
			if (tgt in layerMap){
				nodesData[src].layer = nodesData[tgt].layer + 1;
				tmpLayerMap[src] = 1;
				change++;
			}
		});
		layerMap = tmpLayerMap.slice(0);
		maxLayer++;
	}
	maxLayer--;
	
	//nodesChildren contains the node's id - node's children pair.
	anchorData.forEach(function(d){
		nodesChildren[d.id] = [];
	});
	tmpLinkData.forEach(function(d){
		if (!nodesChildren[d.source]){
			nodesChildren[d.source] = [];
		}
		nodesChildren[d.source].push(d.target);
		nodesData[d.target].parent = d.source;
		nodesData[d.source].degree++;
		nodesData[d.target].degree++;
	});

	//store the node id in the sequence of layer
	//xPos is the x position for nodes in the unit of column's width
	layerMap = d3.range(maxLayer + 1).map(function(d){
		return [];
	});
	nodesData.forEach(function(d){
		layerMap[d.layer].push(d.id);
	});
	layerMap.forEach(function(d, i){
		if (i > 0){
			d.forEach(function(e){
				var tmp = [];
				nodesChildren[e].forEach(function(f){
					tmp.push(nodesData[f].xposCol);
				});				
				nodesData[e].xposCol = (d3.min(tmp) + d3.max(tmp)) / 2;
			}); 
		}
	});
}

//draw columns
function drawTable(){
	var columnName = d3.range(columns).map(function(d){
		return d;
	});
	svg.selectAll("rect")
		.data(columnName)
		.enter()
		.append("rect")
		.attr("x", function(d, i){
			return xScale(i);
		})
		.attr("y", height - 100)
		.attr("height", barHeight)
		.attr("width", barWidth)
		.attr("fill", "steelblue")
		.attr("stroke", "white")
		.attr("stroke-width", 1)
		.attr("opacity", 0.5);
}

//when move over show the coordinate
function  mousemove(){
	var ary = d3.mouse(this);
	pos.attr("x", ary[0] + 2)
		.attr("y", ary[1] + 2)
		//.attr("x", 100)
		//.attr("y", 100)
		.text(Math.round(ary[0]) + ", " + Math.round(ary[1]));
}

//move element to the back of its parent's children
d3.selection.prototype.moveToBack = function() { 
    return this.each(function() { 
        var firstChild = this.parentNode.firstChild; 
        if (firstChild) { 
            this.parentNode.insertBefore(this, firstChild); 
        } 
    });    //move component to the down of svg
};

//move element to the top of its parent's children
d3.selection.prototype.moveToFront = function() {
  return this.each(function(){
    this.parentNode.appendChild(this);
  });   //move component to the up of svg
};

//set the outside nodes
function setNodePosition(){
	var num = 0;
	var change = 0;
	//check if node is outside or not, when the status of node changes, the transition happens
	nodes.each(function(d){
		if (d.position.x - nodeRadius < xOffset || d.position.x + nodeRadius > xOffset + window.innerWidth){
			d3.select(this).classed("fixed", d.fixed = false);
  			d.position.x = barWidth * (0.5 + d.xposCol);
			d.position.y = height - barHeight - nodeRadius - d.layer * unitLinkLength;
		}
		if (d.position.x - nodeRadius < xOffset || d.position.x + nodeRadius > xOffset + window.innerWidth){
			if (!d.outside.isOutside){
				d.outside.isOutside = true;				
				d3.select(this)
					.transition()
					.duration(500)
					.attr("opacity", 0.5)
					.attr("r", nodeRadius / 2);					
				change++;
				num++;
			}
		} else {
			if (d.outside.isOutside){
				d.outside.isOutside = false;
				d3.select(this)
					.transition()
					.duration(500)
					.attr("opacity", 1)
					.attr("r", nodeRadius);

				change++;
				num--;
			}
		}
	});

	//when some node changes its status, the correspoding links, labels and the x position of inside nodes should also change.
	if (change > 0){
		outsideNodesNum = num;	
		d3.selectAll(".nodeLabel")
			.classed("hiddenText", function(d){
				if (d.type == "nodeLabel" && d.node.outside){
					if ((!d.node.outside.isOutside && d.node.type != "anchor") || (d.node.outside.isOutside && d.node.degree >= 3)){
						d.node.showLabel = true;
						return false;
					}
				}	
				d.node.showLabel = false;
				return true;			
			});
		d3.selectAll(".linkLabel")
			.classed("hiddenText", function(d){
				if (d.type == "linkLabel"){
					if (nodesData[d.node.src].outside.isOutside || nodesData[d.node.tgt].outside.isOutside){
						return true;
					}
					return false;
				}
			})

		links.classed("outsideLink", function(d){
			if (d.source.outside && d.target.outside){
				return d.source.outside.isOutside || d.target.outside.isOutside;
			}
			return false;
		});

		layerMap.forEach(function(d, i){
			if (i > 0){
				d.forEach(function(e){
					if (!nodesData[e].outside.isOutside && !nodesData[e].fixed){
						var tmp = [];
						nodesChildren[e].forEach(function(f){
							if (!nodesData[f].outside.isOutside){
								tmp.push(nodesData[f].xposCol);
							}
						});				
						nodesData[e].xposCol = (d3.min(tmp) + d3.max(tmp)) / 2;
						nodesData[e].position.x = barWidth * (0.5 + nodesData[e].xposCol);
					}
				});
			}
		});		
		force.start();
	}
}

//scroll bar
function scrollBar(distance){
	$(window).scrollLeft(distance);
}

//scroll bar move event
window.onscroll = function(event){
	//console.log(window.pageXOffset);
	if (Math.abs(window.pageXOffset - xOffset) > reshuffleFrequency){
		xOffset = window.pageXOffset;
		setNodePosition();
	}
}

//resize screen event
window.onresize = function(event) {
    width = window.innerWidth - padding;
    //height=window.innerHeight - padding;
    //console.log(width + " " + height);
};
</script>
</body>
</html>