<html>
<head>
<link rel="stylesheet" href="style.css">
<script type="text/javascript" src="http://d3js.org/d3.v3.min.js">
</script>
</head>


<body>
<script type="text/javascript">
var padding = 35;
var width=window.innerWidth - padding;           //width and height of scope
var height=window.innerHeight - padding;
console.log(window.innerWidth + " " + window.innerHeight)
var nodeRadius = 8;
var columns = 20;
var barWidth = 100;
var barHeight = 100;
var unitLinkLength = 70;
var anchorRange = width / columns; 
var xOffset = 0;
var outsideNodesAreaWidth = 100;

var cScale = d3.scale.category20();            //return color of node

svg = d3.select("body")                         //create svg
    .append("svg")
    .attr("width", Math.max(width, columns * barWidth))
    .attr("height", height)
    .on("mousemove", mousemove);

var forceSVG = svg.append("g");

pos = svg.append("text")
	.attr("fill", "black")
	.attr("font-size", 10);

var xScale = d3.scale.linear()
	.domain([0, columns])                        //5 for columns of table
	//.rangeRoundBands([(width - barWidth * columns) / 2, (width + barWidth * columns) / 2], .1);
	.range([0, barWidth * columns]);

var upperForceScale = d3.scale.linear()
	.domain([0, height])
	//.range([0.2, 0.8]); 
	.range([1, 0]);        


var anchorData = [];
var nodesData = [];
var linksData = [];
var textData = [];
var textLinksData = [];
var idMap = [];
var layerMap = [];
var maxLayer = 0;
var leftOutsideMaxLayer = 0;
var rightOutsideMaxLayer = 0;
var nodesChildren = [];
var leftOutsideAnchorNumber = 0;
var rightOutsideAnchorNumber = 0;
var displayedColumnWidth = Math.floor(width / barWidth) * (barWidth);
var reshuffleFrequency = 10;
var avaliableHeight = 0;
var leftOutsideLayerDifference = 0;
var rightOutsideLayerDifference = 0;

var nodes = forceSVG.selectAll(".node");
var links = forceSVG.selectAll(".link");
var labels = forceSVG.selectAll(".label");
var labelLinks = forceSVG.selectAll(".labelLinks");

var force = d3.layout.force()
	.size([Math.max(width, columns * barWidth), height])
	.gravity(0)
	.linkStrength(0)
	//.friction(0.7)
	//.theta(0.1)
	.charge(-50)
	.linkDistance(function(d){
		var v = (d.source.layer - d.target.layer) * unitLinkLength; 
		var h = Math.abs(d.source.xposCol - d.target.xposCol) * barWidth;
		var dist = Math.sqrt(v * v + h * h);
		return dist;
		//return 100;
	})
	.on("tick", tick);

var labelForce = d3.layout.force()
	.size([Math.max(width, columns * barWidth), height])
	.gravity(0)
	.charge(-100)
	.linkDistance(0)
	.linkStrength(8);

d3.json("datasets/complex/complex01.json", function(d){
//d3.json("datasets/simple/simple05.json", function(d){
	var tmpNodeData = d.anchors.concat(d.nodes);
	var tmpLinkData = d.links;
	initializeData(tmpLinkData, tmpNodeData);
	setLayer();

	drawTable();
	transit();
	setOutsideLayerAndPosition();
	updateNodePosition();

	force.nodes(nodesData)
		.links(linksData)
		.start();

	labelForce.nodes(textData)
		.links(textLinksData)
		.start();
});




function transit(){
	links = links.data(linksData)
	links.enter()
		.append("line")
		.classed("link", true)
		.attr("stroke", "black")
		.attr("stroke-width", 0)
		.attr("opacity", 0.5)
		.attr("id", function(d, i){
			return "link" + i;
		});
	links.transition()
		.delay(250)
		.duration(500)
		.attr("stroke-width", 2);

	nodes = nodes.data(nodesData);
	nodes.enter()
		.append("circle")
		.classed("node", true)
		.attr("r", 2)
		.attr("fill", function(d, i){
			//d.x = barWidth * (0.5 + d.xposCol);
			//d.y = height - barHeight - nodeRadius - d.layer * unitLinkLength;	
			d.position = {};
			d.position.x = barWidth * (0.5 + d.xposCol);
			d.position.y = height - barHeight - nodeRadius - d.layer * unitLinkLength;
			d.outside = {};
			d.outside.position = {};	
			checkOutside(d);
			return cScale(i + 1);
		})
		.attr("id", function(d, i){
			return "node" + i;
		})
		.call(force.drag);
	nodes.transition()
		.duration(500)
		.attr("r", nodeRadius);

	labels = labels.data(textData)
		.enter()
		.append("g")
		.classed("label", true);
	labels.append("circle")
		.attr("r", 0)
		//.attr("fill", "white");
	labels.append("text")
		.text(function(d, i){
			return i % 2 == 0 ? "" : d.content;
		})
		.attr("fill", "black")
		.style("font-family", "Arial")
		.style("font-size", 12)
		.attr("opacity", 0)
		.transition()
		.delay(500)
		.duration(500)
		.attr("opacity", 1);
	labelLinks = labelLinks.data(textLinksData);
	labelLinks.enter()
		.append("line")
		.classed("labelLinks", true)
		.attr("stroke-width", 0);
	//labels.moveToBack();
}

function tick(e){
	labelForce.start();
	var k = 0.1 * e.alpha;
	/*var k = 0.01 * e.alpha * 10;
	nodes.each(function(d){
		if (d.type == "node"){			
			var diffY = 0 - d.y;
			d.y += diffY * k * upperForceScale(d.y);
		}
	})*/
	links.call(updateLink);
    updateNode(k);


    labels.each(function(d, i){
    	if (i % 2 == 0){
    		if (d.type){
    			var a = nodesData[d.node.src];
    			var b = nodesData[d.node.tgt];
    			d.x = (a.x + b.x) / 2;
    			d.y = (a.y + b.y) / 2;
    		} else {
    			d.x = d.node.x;
    			d.y = d.node.y;
    		} 
    	} else {
    		var b = this.childNodes[1].getBBox();
			var diffX = d.x - textData[i - 1].x;
			var diffY = d.y - textData[i - 1].y;
			var dist = Math.sqrt(diffX * diffX + diffY * diffY);
			var shiftX = b.width * (diffX - dist) / (dist * 2);
			shiftX = Math.max(-b.width, Math.min(0, shiftX));
			var shiftY = 4;
			this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
    	}
    })

    labels.call(updateLabel);
    labelLinks.call(updateLink);  	
}

var updateLink = function(){
	this.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
}

var updateNode = function(k){
	//var k = 0.005;
	var kY = 0.05;
	nodes.attr("cx", function(d) { 
			if (d.outside.isOutside){
				if (d.type == "anchor"){
					d.x = d.outside.position.x;
					return Math.round(d.x);
				}
				var differX = d.outside.position.x - d.x;
				d.x += differX * kY;
    			return Math.round(d.x);
			}
			var differX = d.position.x - d.x;
			if (d.type == "anchor"){
				d.x = d.position.x;
				return Math.round(d.x);
			}
    		//d.x = Math.max(nodeRadius, Math.min(Math.max(width, columns * barWidth) - nodeRadius, d.x)); 
    		d.x += differX * kY;
    		return Math.round(d.x);
    	})
        .attr("cy", function(d) { 
        	if (d.outside.isOutside){
				var differY = d.outside.position.y - d.y;
				d.y += differY * kY;
        		return Math.round(d.y);
			}
        	var differY = d.position.y - d.y;
        	//d.y = height - barHeight - nodeRadius - d.layer * unitLinkLength;
        	d.y += differY * kY;
        	return Math.round(d.y);
        });  
}

var updateLabel = function() {
	this.attr("transform", function(d) {
		d.x = Math.max(xOffset + 20, Math.min(xOffset + width, d.x)); 
		d.y = Math.max(nodeRadius, Math.min(height - nodeRadius, d.y)); 
		return "translate(" + d.x + "," + d.y + ")";
	});
}

function initializeData(tmpL, tmpN){
	tmpN.forEach(function(d, i){
		var node = {};
		node.label = d.id;
		node.id = i;
		if (d.column){
			node.column = d.column;
			node.type = "anchor";
			node.layer = 0;
			node.xposCol = d.column;
			anchorData.push(node);
			layerMap[i] = 1;
		} else {
			node.type = "node";
		}
		nodesData.push(node);
		idMap[d.id] = i;

	
		textData.push({node : node});
		textData.push({
			node : node,
			content : d.label,
			type : "nodeLabel"
		});

		textLinksData.push({
			source : textData.length - 2,
			target : textData.length - 1
		});
		
	});

	tmpL.forEach(function(d, i){
		var edge = {};
		edge.source = idMap[d.source];
		edge.target = idMap[d.target];
		edge.id = i;
		linksData.push(edge);

		var node = {};
		node.src = edge.source;
		node.tgt = edge.target;
		textData.push({
			node : node,
			type : "linkCircle"
		});
		textData.push({
			node : node,
			type : "linkLabel",
			content : d.label
		});

		textLinksData.push({
			source : textData.length - 2,
			target : textData.length - 1
		});
	});
}

function setLayer(){
	var change = layerMap.length;
	var tmpLinkData = linksData.slice(0);
	while (change > 0){
		var tmpLayerMap = [];
		change = 0;
		tmpLinkData.forEach(function(d){
			var src = d.source;
			var tgt = d.target;
			if (tgt in layerMap){
				nodesData[src].layer = nodesData[tgt].layer + 1;
				tmpLayerMap[src] = 1;
				change++;
			}
		});
		layerMap = tmpLayerMap.slice(0);
		maxLayer++;
	}


	
	anchorData.forEach(function(d){
		nodesChildren[d.id] = [];
	});
	tmpLinkData.forEach(function(d){
		if (!nodesChildren[d.source]){
			nodesChildren[d.source] = [];
		}
		nodesChildren[d.source].push(d.target);
	});
	layerMap = d3.range(maxLayer + 1).map(function(d){
		return [];
	});
	nodesData.forEach(function(d){
		layerMap[d.layer].push(d.id);
	});
	layerMap.forEach(function(d, i){
		if (i > 0){
			d.forEach(function(e){
				var tmp = [];
				nodesChildren[e].forEach(function(f){
					tmp.push(nodesData[f].xposCol);
				});				
				var xxx =(d3.min(tmp) + d3.max(tmp)) / 2;
				nodesData[e].xposCol = (d3.min(tmp) + d3.max(tmp)) / 2;
			});
		}
	});
	/*nodesData.forEach(function(d, i){
		console.log(i + "  " + d.xposCol);
	})*/
}

function checkOutside(d){
	var preStatus = d.outside.isOutside;
	if (d.position.x < xOffset + outsideNodesAreaWidth){
		if (!d.outside.isOutside){
			d.outside.isOutside = true;
			if (d.type == "anchor"){
				leftOutsideAnchorNumber++;
				d.outside.index = -leftOutsideAnchorNumber;
			}
			d.outside.direction = "left";
		}
	} else if (d.position.x > xOffset + displayedColumnWidth - outsideNodesAreaWidth){
		if (!d.outside.isOutside){
			d.outside.isOutside = true;
			if (d.type == "anchor"){
				rightOutsideAnchorNumber++;
				d.outside.index = rightOutsideAnchorNumber;
			}
			d.outside.direction = "right";
		}
	} else {
		if (d.outside.isOutside){
			d.outside.isOutside = false;
			d.outside.position = {};
			d.outside.direction = "";
			if (d.outside.index){
				if (d.outside.index < 0){
					leftOutsideAnchorNumber--;
				} else {
					rightOutsideAnchorNumber--;
				}
			}
		}
	}
	if (preStatus != d.outside.isOutside){
		return 1;
	} else {
		return 0;
	}
}

function setOutsideLayerAndPosition(){
	console.log("setOutsideLayerAndPosition");
	leftOutsideMaxLayer = 0;
	rightOutsideMaxLayer = 0;
	layerMap.forEach(function(d, i){
		if (i == 0){
			d.forEach(function(e){
				if (nodesData[e].outside.isOutside){
					if (nodesData[e].outside.index < 0){
						nodesData[e].outside.layer = leftOutsideAnchorNumber + nodesData[e].outside.index;
						leftOutsideMaxLayer = Math.max(leftOutsideMaxLayer, nodesData[e].outside.layer);
					} else {
						nodesData[e].outside.layer = nodesData[e].outside.index - 1; 
						rightOutsideMaxLayer = Math.max(rightOutsideMaxLayer, nodesData[e].outside.layer);
					}
					console.log(nodesData[e].label + " " + nodesData[e].outside.layer);
				}
			});
		} else {
			d.forEach(function(e){
				if (nodesData[e].outside.isOutside){
					var tmp = [];
					nodesChildren[e].forEach(function(f){
						if (nodesData[f].outside.isOutside){
							tmp.push(nodesData[f].outside.layer);
						}
					});
					nodesData[e].outside.layer = d3.max(tmp) + 1;
					console.log(nodesData[e].label + " " + nodesData[e].outside.layer);
					if (nodesData[e].outside.direction == "left"){
						leftOutsideMaxLayer = Math.max(leftOutsideMaxLayer, nodesData[e].outside.layer);
					} else {
						rightOutsideMaxLayer = Math.max(rightOutsideMaxLayer, nodesData[e].outside.layer);
					}
				}
			});
		}
	});

	avaliableHeight = (maxLayer - 1) * unitLinkLength;
	leftOutsideLayerDifference = avaliableHeight / leftOutsideMaxLayer;
	rightOutsideLayerDifference = avaliableHeight / rightOutsideMaxLayer;	
	nodesData.forEach(function(d){
		if (d.outside.isOutside){
			if (d.outside.direction == "left"){
				d.outside.position.y = height - barWidth - nodeRadius - d.outside.layer * leftOutsideLayerDifference;
				d.outside.position.x = d.layer * leftOutsideLayerDifference + xOffset + nodeRadius;
			} else {
				d.outside.position.y = height - barWidth - nodeRadius - d.outside.layer * rightOutsideLayerDifference;
				d.outside.position.x = xOffset + width + 20 - d.layer * rightOutsideLayerDifference;
			}
		} 
	})
}

function updateNodePosition(){
	nodesData.forEach(function(d){
		if (d.outside.isOutside){
			if (d.outside.direction == "left"){
				d.outside.position.y = height - barWidth - nodeRadius - d.outside.layer * leftOutsideLayerDifference;
				d.outside.position.x = d.layer * leftOutsideLayerDifference + xOffset + nodeRadius;
			} else {
				d.outside.position.y = height - barWidth - nodeRadius - d.outside.layer * rightOutsideLayerDifference;
				d.outside.position.x = xOffset + width + 20 - d.layer * rightOutsideLayerDifference;
			}
		}
	});
	layerMap.forEach(function(d, i){
		if (i > 0){
			d.forEach(function(e){
				if (!nodesData[e].outside.isOutside){
					var tmp = [];
					nodesChildren[e].forEach(function(f){
						if (!nodesData[f].outside.isOutside){
							tmp.push(nodesData[f].xposCol);
						}
					});				
					nodesData[e].xposCol = (d3.min(tmp) + d3.max(tmp)) / 2;
					nodesData[e].position.x = barWidth * (0.5 + nodesData[e].xposCol);
				}
			});
		}
	});
}

function drawTable(){
	var columnName = d3.range(columns).map(function(d){
		return d;
	});
	svg.selectAll("rect")
		.data(columnName)
		.enter()
		.append("rect")
		.attr("x", function(d, i){
			return xScale(i);
		})
		.attr("y", height - 100)
		.attr("height", barHeight)
		.attr("width", barWidth)
		.attr("fill", "steelblue")
		.attr("stroke", "white")
		.attr("stroke-width", 1)
		.attr("opacity", 0.5);
}

function  mousemove(){
	var ary = d3.mouse(this);
	pos.attr("x", ary[0] + 2)
		.attr("y", ary[1] + 2)
		//.attr("x", 100)
		//.attr("y", 100)
		.text(Math.round(ary[0]) + ", " + Math.round(ary[1]));
}

d3.selection.prototype.moveToBack = function() { 
    return this.each(function() { 
        var firstChild = this.parentNode.firstChild; 
        if (firstChild) { 
            this.parentNode.insertBefore(this, firstChild); 
        } 
    });    //move component to the down of svg
};

d3.selection.prototype.moveToFront = function() {
  return this.each(function(){
    this.parentNode.appendChild(this);
  });   //move component to the up of svg
};

window.onscroll = function(event){
	if (Math.abs(window.pageXOffset - xOffset) > reshuffleFrequency){
		xOffset = window.pageXOffset;
		var change = 0;
		nodesData.forEach(function(d){
			change += checkOutside(d);
		})
		console.log("change : " + change)
		if (change > 0){
			setOutsideLayerAndPosition();
			force.start();
		}
		updateNodePosition();
	}
}
</script>
</body>
</html>